# 水塘抽样

## 简介
+ 作用：对于一个很大的集合，抽取的样本值能够保证随机
+ 特点：复杂度是O(n),并且很大程度上能节省内存

## 问题
+ 长度为n的链表，n的值非常大，不清楚n的确切值，如何写一个尽可能高效的算法来返回k个完全随机的数。
+ 限制：高效，节省内存的使用；尽量随机的返回值

## 分析
+ 假如去掉节省内存的使用，可以很简单的做出来，将所有数据放到内存里，计算链表的长度，然后rand()%len，求k次即可
+ 注意题目中的提示，链表，数据首尾相连形成的链式存储结构，我们可以一个一个节点去处理
+ 新描述：我们有1T的文本文件存在硬盘中，想随机抽取几行，保证尽可能少的使用内存，并能完全随机
+ 做法1：我们可以只用一行的内存，每次取一行的记录放进来，然后求出长度，然后rand()%n，求出k个随机值，然后在遍历一遍，看是不是在这k个里面，遍历两次即可
+ 做法2：遍历两次1T的数据要很久，更好的方法：水塘抽样

## 算法


```C++
// 
vector<int> solve(vector<int> s, int k){
    int n = s.size();
    vector<int> ans(k,0);
    for(int i=0;i<k;i++) ans[i] = s[i];
    for(int i=k;i<n;i++){
        int x = rand()%i;
        if(x < k) R[x] = s[i];  
    }
    return ans;
}

```
## 证明
考虑最终 s[i] 是答案的概率：即 i 被放入结果集，而且之后没有被替换掉。
$$p(i) = k/i*\prod_{i+1}^{n}(1-1/n) = k/n$$

## 相关题目

leetcode382:随机节点
 

